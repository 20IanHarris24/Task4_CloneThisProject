1. Hur fungerar stacken och heapen? Förklara gärna med exempel eller skiss på dess
grundläggande funktion

The stack is a memory data structure where elements are stacked together and the use mechanism is LIFO (Last In First Out). 
If however we want to use an element further down the stack, the elements above it will need to be moved to be able to access the information from the chosen element.
The stack keeps track of which calls and methods are being executed and when the method has been executed its state is released from the stack.

Stack example

|      |¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|       | element D
|      |¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|       | element C
|      |¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|       | element B
|      |¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|       | element A
|       ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯        |
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
The Heap is a memory data structure where all elements are accessible immediately with a simple mechanism for access. 
The Heap holds information generated by reference types however has no knowledge of when it will be used, meaning even after a method execution which may use the data from heapen
it will not be removed directly after execution. 
Memory management is performed through Garbage Collection, which will releaase memeory based on elements not having references or ar not in use anymore.

Heap example

                                    |¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|        element D
      |¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|  element C   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
       ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯                                               |¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|       | element B
                                    |¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯|    element A    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
                                     ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯        




2. Vad är Value Types respektive Reference Types och vad skiljer dem åt?

A Value type will contain an instance of the type and is typically stored in Stack.
A Reference type will contain a reference to an instance of the type and is typically store in Heap.


3. Följande metoder (se bild nedan) genererar olika svar. Den första returnerar 3, den
andra returnerar 4, varför? 


public int ReturnValue()
{
    int x = new int();
    x = 3;
    int y = new int();
    y = x;
    y = 4;
    return x;
}

public int ReturnValue2()
{
    Myint x = new Myint();
    x.MyValue = 3;
    Myint y = new Myint();
    y = x;
    y.MyValue = 4;
    return x.Myvalue;
}




In the first method
int object of x is created (value type)
int object of y is created (value type)
only a copy of the reference (pointer) of x is then assigned to y (not the actual value of x), so setting y to 4 will not affect the x object
meaning that the actual value from x (3) is returned as that object has not been updated.

In the second method
class Myint is created (reference type) and a new object x of the class Myint instansiated and set to value 3
class Myint is created (reference type) and a new object y of the class Myint instansiated 
The object reference pointer of x is assigned to y. This means y and x through the same reference access the same object, currently the value = 3
Updating the y object field MyValue with 4 means that x value returened will also = 4. 



Övning 1: ExamineList()

1. See code
2. At program execution the list capacity is set to 0 element array but after entering the 1st name the list capacity increases
3. The capacity increase to a 4 element array or by 400%
4. The List class works on the premise of flexibility
i.e. not knowing how many elements will populate the list so pre-allocates space to give that flexibility.
5. No. the underlying capacity will be kept even if elements are removed.
6. If the maximum amount of elements to be processed is already known, then having a defined array at runtime is probably more advantageous. 


Övning 2: ExamineQueue()

1. See code
2. At program execution the list capacity is set to 0 element array but after entering the 1st name the list capacity increases
3. The capacity increase to a 4 element array or by 400%
4. The List class works on the premise of flexibility
i.e. not knowing how many elements will populate the list so pre-allocates space to give that flexibility.
5. No. the underlying capacity will be kept even if elements are removed.
6. If the maximum amount of elements to be processed is already known, then having a defined array at runtime is probably more advantageous.


Övning 3: ExamineStack()

1. See code. Because the stack uses a first in last out(FILO) algorithm with a Push/Pop mechanism to retrieve an element that is at the bottom of the stack
uses means more data-shuffling, than with the Queue method, has it would have to remove all elements in the way of the wanted one.
2. See code.




